/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/interactive-campus-map.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/interactive-campus-map.js":
/*!******************************************!*\
  !*** ./src/js/interactive-campus-map.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function ($) {
  $(document).ready(function () {
    var app = document.getElementById('campus-map');
    var sidebar = document.getElementById('campus-map-sidebar');
    var wrapper = app.getElementsByClassName('campus-map')[0];
    var component = app.getElementsByClassName('campus-map-component')[0];
    var areas = app.querySelectorAll('[data-area]');
    var zoomOut = document.getElementById('zoom-out');
    var resetBtn = document.getElementById('reset');
    var closeBtn = sidebar.getElementsByClassName("campus-map-sidebar--close")[0];
    var svg = wrapper.querySelector('svg'); // This variable will be used later for move events to check if pointer is down or not

    var isPointerDown = false; // This variable will contain the original coordinates when the user start pressing the mouse or touching the screen

    var pointerOrigin = {
      x: 0,
      y: 0
    };
    var transform = {
      x: 0,
      y: 0,
      z: 0
    };
    var newTransform = {
      x: 0,
      y: 0,
      z: 0
    };
    var scale = 1; // Function called by the event listeners when user start pressing/touching

    function onPointerDown(event) {
      isPointerDown = true; // We set the pointer as down

      scale = wrapper.dataset.zoom; // We get the pointer position on click/touchdown so we can get the value once the user starts to drag

      var pointerPosition = getPointFromEvent(event);
      pointerOrigin.x = pointerPosition.x;
      pointerOrigin.y = pointerPosition.y;
    } // This function returns an object with X & Y values from the pointer event


    function getPointFromEvent(event) {
      var point = {
        x: 0,
        y: 0
      }; // If event is triggered by a touch event, we get the position of the first finger

      if (event.targetTouches) {
        point.x = event.targetTouches[0].clientX;
        point.y = event.targetTouches[0].clientY;
      } else {
        point.x = event.clientX;
        point.y = event.clientY;
      }

      return point;
    } // Function called by the event listeners when user start moving/dragging


    function onPointerMove(event) {
      // Only run this function if the pointer is down
      if (!isPointerDown) {
        return;
      } // This prevent user to do a selection on the page


      event.preventDefault();
      event.stopPropagation(); // Get the pointer position

      var pointerPosition = getPointFromEvent(event); // We calculate the distance between the pointer origin and the current position
      // The viewBox x & y values must be calculated from the original values and the distances

      newTransform.x = transform.x + (pointerPosition.x - pointerOrigin.x);
      newTransform.y = transform.y + (pointerPosition.y - pointerOrigin.y);
      setTransform(newTransform.x, newTransform.y);
    }

    function onPointerUp() {
      // The pointer is no longer considered as down
      isPointerDown = false; // Multiply the scale level to get the number to multiply the SVG by

      var scaleChange = scale > 1 ? scale * 0.6 : 1; // Get width and height of the SVG multiplied by the scale. This gives the correct zoomed in size of the SVG

      var svgWidth = svg.width.baseVal.value * scaleChange;
      var svgHeight = svg.height.baseVal.value * scaleChange; // Get the bounds of the SVG. Takes the width/height minus the width/height of the component.
      // The remaining amount of the size outside of the bounds. Divided by 2 gives the amount each side is allowed to move.

      var boundsLeft = (svgWidth - component.offsetWidth) / 2;
      var boundsTop = (svgHeight - component.offsetHeight) / 2;
      var boundsRight = (component.offsetWidth - svgWidth) / 2;
      var boundsBottom = (component.offsetHeight - svgHeight) / 2; // Set the transform X value

      if (newTransform.x > 0 && scale == 1) {
        transform.x = 0;
      } else if (newTransform.x > boundsLeft) {
        transform.x = boundsLeft;
      } else if (newTransform.x < boundsRight) {
        transform.x = boundsRight;
      } else {
        transform.x = newTransform.x;
      } // Set the transform Y value


      if (newTransform.y > 0 && scale == 1) {
        transform.y = 0;
      } else if (newTransform.y > boundsTop) {
        transform.y = boundsTop;
      } else if (newTransform.y < boundsBottom) {
        transform.y = boundsBottom;
      } else {
        transform.y = newTransform.y;
      }

      setTransform(transform.x, transform.y);
    }

    function setTransform(x, y) {
      var transformString = "".concat(x, "px, ").concat(y, "px, 0"); // We apply the new viewBox values onto the SVG

      component.style.transform = "translate3d(" + transformString + ")";
    } // If browser supports pointer events


    if (window.PointerEvent) {
      svg.addEventListener('pointerdown', onPointerDown); // Pointer is pressed

      svg.addEventListener('pointerup', onPointerUp); // Releasing the pointer

      svg.addEventListener('pointerleave', onPointerUp); // Pointer gets out of the SVG area

      svg.addEventListener('pointermove', onPointerMove); // Pointer is moving
    } else {
      // Add all mouse events listeners fallback
      svg.addEventListener('mousedown', onPointerDown); // Pressing the mouse

      svg.addEventListener('mouseup', onPointerUp); // Releasing the mouse

      svg.addEventListener('mouseleave', onPointerUp); // Mouse gets out of the SVG area

      svg.addEventListener('mousemove', onPointerMove); // Mouse is moving
      // Add all touch events listeners fallback

      svg.addEventListener('touchstart', onPointerDown); // Finger is touching the screen

      svg.addEventListener('touchend', onPointerUp); // Finger is no longer touching the screen

      svg.addEventListener('touchmove', onPointerMove); // Finger is moving
    }

    var closesidebar = function closesidebar() {
      svg.classList.remove("selected");
      app.classList.remove("sidebar--active");

      for (var index = 0; index < areas.length; index++) {
        var area = areas[index];
        area.classList.remove("area--selected");
      }
    };

    closeBtn.addEventListener("click", function () {
      closesidebar();
    });
    zoomOut.addEventListener("click", function () {
      scale = wrapper.dataset.zoom;
      var scaleChange = scale > 1 ? scale * 0.6 : 1;
      var positionX, positionY;
      positionX = newTransform.x - newTransform.x / scaleChange;
      positionY = newTransform.y - newTransform.y / scaleChange;
      transform = {
        x: positionX,
        y: positionY,
        z: 0
      };
      newTransform = {
        x: positionX,
        y: positionY,
        z: 0
      };
      setTransform(transform.x, transform.y);
    });
    resetBtn.addEventListener("click", function () {
      transform = {
        x: 0,
        y: 0,
        z: 0
      };
      newTransform = {
        x: 0,
        y: 0,
        z: 0
      };
      setTransform(0, 0);
      zoomOut.classList.add("disabled");
    });
    document.addEventListener('keydown', function (event) {
      if ('Escape' == event.code) {
        closesidebar();
      }
    });
  });
})(jQuery);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2ludGVyYWN0aXZlLWNhbXB1cy1tYXAuanMiXSwibmFtZXMiOlsiJCIsImRvY3VtZW50IiwicmVhZHkiLCJhcHAiLCJnZXRFbGVtZW50QnlJZCIsInNpZGViYXIiLCJ3cmFwcGVyIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImNvbXBvbmVudCIsImFyZWFzIiwicXVlcnlTZWxlY3RvckFsbCIsInpvb21PdXQiLCJyZXNldEJ0biIsImNsb3NlQnRuIiwic3ZnIiwicXVlcnlTZWxlY3RvciIsImlzUG9pbnRlckRvd24iLCJwb2ludGVyT3JpZ2luIiwieCIsInkiLCJ0cmFuc2Zvcm0iLCJ6IiwibmV3VHJhbnNmb3JtIiwic2NhbGUiLCJvblBvaW50ZXJEb3duIiwiZXZlbnQiLCJkYXRhc2V0Iiwiem9vbSIsInBvaW50ZXJQb3NpdGlvbiIsImdldFBvaW50RnJvbUV2ZW50IiwicG9pbnQiLCJ0YXJnZXRUb3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJvblBvaW50ZXJNb3ZlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJzZXRUcmFuc2Zvcm0iLCJvblBvaW50ZXJVcCIsInNjYWxlQ2hhbmdlIiwic3ZnV2lkdGgiLCJ3aWR0aCIsImJhc2VWYWwiLCJ2YWx1ZSIsInN2Z0hlaWdodCIsImhlaWdodCIsImJvdW5kc0xlZnQiLCJvZmZzZXRXaWR0aCIsImJvdW5kc1RvcCIsIm9mZnNldEhlaWdodCIsImJvdW5kc1JpZ2h0IiwiYm91bmRzQm90dG9tIiwidHJhbnNmb3JtU3RyaW5nIiwic3R5bGUiLCJ3aW5kb3ciLCJQb2ludGVyRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xvc2VzaWRlYmFyIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiaW5kZXgiLCJsZW5ndGgiLCJhcmVhIiwicG9zaXRpb25YIiwicG9zaXRpb25ZIiwiYWRkIiwiY29kZSIs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Q0FnQixZQUFZLENBQUUsQ0FBRixFQUFLLENBQUwsQ0FBWjtNQUVBMUIsT0FBTyxDQUFDK0MsU0FBUixDQUFrQk8sR0FBbEIsQ0FBdUIsVUFBdkI7SUFFSCxDQVJEO0lBVUFoRSxRQUFRLENBQUN1RCxnQkFBVCxDQUEyQixTQUEzQixFQUFzQyxVQUFBL0IsS0FBSyxFQUFJO01BQzNDLElBQUksWUFBWUEsS0FBSyxDQUFDeUMsSUFBdEIsRUFBNkI7UUFDekJULFlBQVk7TUFDZjtJQUNKLENBSkQ7RUFNSCxDQTFNRDtBQTRNSCxDQTlNRCxFQThNSVUsTUE5TUosRSIsImZpbGUiOiJjYW1wdXMtbWFwLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2J1aWxkXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2pzL2ludGVyYWN0aXZlLWNhbXB1cy1tYXAuanNcIik7XG4iLCIoIGZ1bmN0aW9uKCAkICkge1xuXG4gICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBjb25zdCBhcHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtcHVzLW1hcCcpO1xuICAgICAgICBjb25zdCBzaWRlYmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbXB1cy1tYXAtc2lkZWJhcicpO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gYXBwLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NhbXB1cy1tYXAnKVswXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NhbXB1cy1tYXAtY29tcG9uZW50JylbMF07XG4gICAgICAgIGNvbnN0IGFyZWFzID0gYXBwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFyZWFdJyk7XG5cbiAgICAgICAgY29uc3Qgem9vbU91dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd6b29tLW91dCcpO1xuICAgICAgICBjb25zdCByZXNldEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNldCcpO1xuICAgICAgICBjb25zdCBjbG9zZUJ0biA9IHNpZGViYXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhbXB1cy1tYXAtc2lkZWJhci0tY2xvc2VcIilbMF07XG5cbiAgICAgICAgY29uc3Qgc3ZnID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcblxuICAgICAgICAvLyBUaGlzIHZhcmlhYmxlIHdpbGwgYmUgdXNlZCBsYXRlciBmb3IgbW92ZSBldmVudHMgdG8gY2hlY2sgaWYgcG9pbnRlciBpcyBkb3duIG9yIG5vdFxuICAgICAgICBsZXQgaXNQb2ludGVyRG93biA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFRoaXMgdmFyaWFibGUgd2lsbCBjb250YWluIHRoZSBvcmlnaW5hbCBjb29yZGluYXRlcyB3aGVuIHRoZSB1c2VyIHN0YXJ0IHByZXNzaW5nIHRoZSBtb3VzZSBvciB0b3VjaGluZyB0aGUgc2NyZWVuXG4gICAgICAgIGxldCBwb2ludGVyT3JpZ2luID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuICAgICAgICBsZXQgbmV3VHJhbnNmb3JtID0geyB4OiAwLCB5OiAwLCB6OiAwIH1cblxuICAgICAgICBsZXQgc2NhbGUgPSAxO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgZXZlbnQgbGlzdGVuZXJzIHdoZW4gdXNlciBzdGFydCBwcmVzc2luZy90b3VjaGluZ1xuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGlzUG9pbnRlckRvd24gPSB0cnVlOyAvLyBXZSBzZXQgdGhlIHBvaW50ZXIgYXMgZG93blxuICAgICAgICAgICAgc2NhbGUgPSB3cmFwcGVyLmRhdGFzZXQuem9vbTtcblxuICAgICAgICAgICAgLy8gV2UgZ2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uIG9uIGNsaWNrL3RvdWNoZG93biBzbyB3ZSBjYW4gZ2V0IHRoZSB2YWx1ZSBvbmNlIHRoZSB1c2VyIHN0YXJ0cyB0byBkcmFnXG4gICAgICAgICAgICBsZXQgcG9pbnRlclBvc2l0aW9uID0gZ2V0UG9pbnRGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgICAgICBwb2ludGVyT3JpZ2luLnggPSBwb2ludGVyUG9zaXRpb24ueDtcbiAgICAgICAgICAgIHBvaW50ZXJPcmlnaW4ueSA9IHBvaW50ZXJQb3NpdGlvbi55O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHdpdGggWCAmIFkgdmFsdWVzIGZyb20gdGhlIHBvaW50ZXIgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRGcm9tRXZlbnQgKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGxldCBwb2ludCA9IHt4OjAsIHk6MH07XG5cbiAgICAgICAgICAgIC8vIElmIGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhIHRvdWNoIGV2ZW50LCB3ZSBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSBldmVudCBsaXN0ZW5lcnMgd2hlbiB1c2VyIHN0YXJ0IG1vdmluZy9kcmFnZ2luZ1xuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlIChldmVudCkge1xuXG4gICAgICAgICAgICAvLyBPbmx5IHJ1biB0aGlzIGZ1bmN0aW9uIGlmIHRoZSBwb2ludGVyIGlzIGRvd25cbiAgICAgICAgICAgIGlmICggISBpc1BvaW50ZXJEb3duICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50IHVzZXIgdG8gZG8gYSBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgcG9pbnRlclBvc2l0aW9uID0gZ2V0UG9pbnRGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBXZSBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50ZXIgb3JpZ2luIGFuZCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgLy8gVGhlIHZpZXdCb3ggeCAmIHkgdmFsdWVzIG11c3QgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBvcmlnaW5hbCB2YWx1ZXMgYW5kIHRoZSBkaXN0YW5jZXNcbiAgICAgICAgICAgIG5ld1RyYW5zZm9ybS54ID0gdHJhbnNmb3JtLnggKyAocG9pbnRlclBvc2l0aW9uLnggLSBwb2ludGVyT3JpZ2luLngpO1xuICAgICAgICAgICAgbmV3VHJhbnNmb3JtLnkgPSB0cmFuc2Zvcm0ueSArIChwb2ludGVyUG9zaXRpb24ueSAtIHBvaW50ZXJPcmlnaW4ueSk7XG5cbiAgICAgICAgICAgIHNldFRyYW5zZm9ybSggbmV3VHJhbnNmb3JtLngsIG5ld1RyYW5zZm9ybS55ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKCkge1xuXG4gICAgICAgICAgICAvLyBUaGUgcG9pbnRlciBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBhcyBkb3duXG4gICAgICAgICAgICBpc1BvaW50ZXJEb3duID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBzY2FsZSBsZXZlbCB0byBnZXQgdGhlIG51bWJlciB0byBtdWx0aXBseSB0aGUgU1ZHIGJ5XG4gICAgICAgICAgICBsZXQgc2NhbGVDaGFuZ2UgPSAoc2NhbGUgPiAxKSA/IHNjYWxlICogMC42IDogMTtcblxuICAgICAgICAgICAgLy8gR2V0IHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIFNWRyBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsZS4gVGhpcyBnaXZlcyB0aGUgY29ycmVjdCB6b29tZWQgaW4gc2l6ZSBvZiB0aGUgU1ZHXG4gICAgICAgICAgICBjb25zdCBzdmdXaWR0aCA9IHN2Zy53aWR0aC5iYXNlVmFsLnZhbHVlICogc2NhbGVDaGFuZ2U7XG4gICAgICAgICAgICBjb25zdCBzdmdIZWlnaHQgPSBzdmcuaGVpZ2h0LmJhc2VWYWwudmFsdWUgKiBzY2FsZUNoYW5nZTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBib3VuZHMgb2YgdGhlIFNWRy4gVGFrZXMgdGhlIHdpZHRoL2hlaWdodCBtaW51cyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGFtb3VudCBvZiB0aGUgc2l6ZSBvdXRzaWRlIG9mIHRoZSBib3VuZHMuIERpdmlkZWQgYnkgMiBnaXZlcyB0aGUgYW1vdW50IGVhY2ggc2lkZSBpcyBhbGxvd2VkIHRvIG1vdmUuXG4gICAgICAgICAgICBjb25zdCBib3VuZHNMZWZ0ID0gKHN2Z1dpZHRoIC0gY29tcG9uZW50Lm9mZnNldFdpZHRoKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNUb3AgPSAoc3ZnSGVpZ2h0IC0gY29tcG9uZW50Lm9mZnNldEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzUmlnaHQgPSAoY29tcG9uZW50Lm9mZnNldFdpZHRoIC0gc3ZnV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0JvdHRvbSA9IChjb21wb25lbnQub2Zmc2V0SGVpZ2h0IC0gc3ZnSGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdHJhbnNmb3JtIFggdmFsdWVcbiAgICAgICAgICAgIGlmICggbmV3VHJhbnNmb3JtLnggPiAwICYmIHNjYWxlID09IDEgKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggbmV3VHJhbnNmb3JtLnggPiBib3VuZHNMZWZ0ICkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gYm91bmRzTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5ld1RyYW5zZm9ybS54IDwgYm91bmRzUmlnaHQgKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnggPSBib3VuZHNSaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnggPSBuZXdUcmFuc2Zvcm0ueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSB0cmFuc2Zvcm0gWSB2YWx1ZVxuICAgICAgICAgICAgaWYgKCBuZXdUcmFuc2Zvcm0ueSA+IDAgJiYgc2NhbGUgPT0gMSApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBuZXdUcmFuc2Zvcm0ueSA+IGJvdW5kc1RvcCApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IGJvdW5kc1RvcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5ld1RyYW5zZm9ybS55IDwgYm91bmRzQm90dG9tICkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS55ID0gYm91bmRzQm90dG9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IG5ld1RyYW5zZm9ybS55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm0oIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oIHgsIHkgKSB7XG5cbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1TdHJpbmcgPSBgJHt4fXB4LCAke3l9cHgsIDBgO1xuXG4gICAgICAgICAgICAvLyBXZSBhcHBseSB0aGUgbmV3IHZpZXdCb3ggdmFsdWVzIG9udG8gdGhlIFNWR1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlM2QoXCIgKyB0cmFuc2Zvcm1TdHJpbmcgKyBcIilcIjtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50c1xuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93bik7IC8vIFBvaW50ZXIgaXMgcHJlc3NlZFxuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKTsgLy8gUmVsZWFzaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgb25Qb2ludGVyVXApOyAvLyBQb2ludGVyIGdldHMgb3V0IG9mIHRoZSBTVkcgYXJlYVxuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSk7IC8vIFBvaW50ZXIgaXMgbW92aW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgYWxsIG1vdXNlIGV2ZW50cyBsaXN0ZW5lcnMgZmFsbGJhY2tcbiAgICAgICAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblBvaW50ZXJEb3duKTsgLy8gUHJlc3NpbmcgdGhlIG1vdXNlXG4gICAgICAgICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTsgLy8gUmVsZWFzaW5nIHRoZSBtb3VzZVxuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblBvaW50ZXJVcCk7IC8vIE1vdXNlIGdldHMgb3V0IG9mIHRoZSBTVkcgYXJlYVxuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpOyAvLyBNb3VzZSBpcyBtb3ZpbmdcblxuICAgICAgICAgICAgLy8gQWRkIGFsbCB0b3VjaCBldmVudHMgbGlzdGVuZXJzIGZhbGxiYWNrXG4gICAgICAgICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uUG9pbnRlckRvd24pOyAvLyBGaW5nZXIgaXMgdG91Y2hpbmcgdGhlIHNjcmVlblxuICAgICAgICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApOyAvLyBGaW5nZXIgaXMgbm8gbG9uZ2VyIHRvdWNoaW5nIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTsgLy8gRmluZ2VyIGlzIG1vdmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xvc2VzaWRlYmFyID0gKCkgPT4ge1xuXG4gICAgICAgICAgICBzdmcuY2xhc3NMaXN0LnJlbW92ZSggXCJzZWxlY3RlZFwiICk7XG4gICAgICAgICAgICBhcHAuY2xhc3NMaXN0LnJlbW92ZShcInNpZGViYXItLWFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgZm9yICggbGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcmVhcy5sZW5ndGg7IGluZGV4KysgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gYXJlYXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgYXJlYS5jbGFzc0xpc3QucmVtb3ZlKCBcImFyZWEtLXNlbGVjdGVkXCIgKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VCdG4uYWRkRXZlbnRMaXN0ZW5lciggXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsb3Nlc2lkZWJhcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6b29tT3V0LmFkZEV2ZW50TGlzdGVuZXIoIFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHNjYWxlID0gd3JhcHBlci5kYXRhc2V0Lnpvb207XG4gICAgICAgICAgICBsZXQgc2NhbGVDaGFuZ2UgPSAoc2NhbGUgPiAxKSA/IHNjYWxlICogMC42IDogMTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvblgsIHBvc2l0aW9uWTtcblxuICAgICAgICAgICAgcG9zaXRpb25YID0gbmV3VHJhbnNmb3JtLnggLSAoIG5ld1RyYW5zZm9ybS54IC8gc2NhbGVDaGFuZ2UgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uWSA9IG5ld1RyYW5zZm9ybS55IC0gKCBuZXdUcmFuc2Zvcm0ueSAvIHNjYWxlQ2hhbmdlICk7XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHsgeDogcG9zaXRpb25YLCB5OiBwb3NpdGlvblksIHo6IDAgfVxuICAgICAgICAgICAgbmV3VHJhbnNmb3JtID0geyB4OiBwb3NpdGlvblgsIHk6IHBvc2l0aW9uWSwgejogMCB9XG5cbiAgICAgICAgICAgIHNldFRyYW5zZm9ybSggdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55ICk7XG5cbiAgICAgICAgfSlcblxuICAgICAgICByZXNldEJ0bi5hZGRFdmVudExpc3RlbmVyKCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuICAgICAgICAgICAgbmV3VHJhbnNmb3JtID0geyB4OiAwLCB5OiAwLCB6OiAwIH1cbiAgICAgICAgICAgIHNldFRyYW5zZm9ybSggMCwgMCApO1xuXG4gICAgICAgICAgICB6b29tT3V0LmNsYXNzTGlzdC5hZGQoIFwiZGlzYWJsZWRcIiApO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYoICdFc2NhcGUnID09IGV2ZW50LmNvZGUgKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzaWRlYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbn0pKCBqUXVlcnkgKTsiXSwic291cmNlUm9vdCI6IiJ9